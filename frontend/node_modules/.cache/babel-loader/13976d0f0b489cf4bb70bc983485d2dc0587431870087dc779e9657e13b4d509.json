{"ast":null,"code":"import { createClient } from '@supabase/supabase-js';\n\n// Initialize Supabase client\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'https://xmdfjheusbiqklrqxgow.supabase.co';\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhtZGZqaGV1c2JpcWtscnF4Z293Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkyNDkzMzUsImV4cCI6MjA3NDgyNTMzNX0.3GsHStv3AqLjWIAZjL8hY4ESEJ-T4MdIpVkebzJ2aaI';\nconst supabase = createClient(supabaseUrl, supabaseAnonKey);\nexport const supabaseService = {\n  /**\n   * Upload a file to the User_Files bucket\n   * @param {File} file - The file to upload\n   * @param {string} userId - User ID for organizing files\n   * @param {string} category - Category for organizing files (academic, schedule, documents, resources)\n   * @returns {Promise<Object>} Upload result with file path and URL\n   */\n  async uploadFile(file, userId = 'default_user', category = 'documents') {\n    try {\n      // Generate unique filename with timestamp\n      const timestamp = new Date().getTime();\n      const fileExtension = file.name.split('.').pop();\n      const fileName = `${userId}/${category}/${timestamp}_${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;\n      console.log('Uploading file:', fileName);\n\n      // Upload file to Supabase Storage\n      const {\n        data,\n        error\n      } = await supabase.storage.from('User_Files').upload(fileName, file, {\n        cacheControl: '3600',\n        upsert: false\n      });\n      if (error) {\n        console.error('Upload error:', error);\n        throw new Error(`Upload failed: ${error.message}`);\n      }\n\n      // Get public URL for the uploaded file\n      const {\n        data: urlData\n      } = supabase.storage.from('User_Files').getPublicUrl(fileName);\n      console.log('File uploaded successfully:', data);\n      return {\n        success: true,\n        filePath: data.path,\n        publicUrl: urlData.publicUrl,\n        fileName: file.name,\n        fileSize: file.size,\n        fileType: file.type || 'application/octet-stream',\n        uploadedAt: new Date().toISOString(),\n        category\n      };\n    } catch (error) {\n      console.error('Supabase upload error:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  },\n  /**\n   * List files from the User_Files bucket\n   * @param {string} userId - User ID to filter files\n   * @param {string} category - Optional category filter\n   * @returns {Promise<Array>} List of files\n   */\n  async listFiles(userId = 'default_user', category = null) {\n    try {\n      const folderPath = category ? `${userId}/${category}` : userId;\n      const {\n        data,\n        error\n      } = await supabase.storage.from('User_Files').list(folderPath, {\n        limit: 100,\n        offset: 0,\n        sortBy: {\n          column: 'created_at',\n          order: 'desc'\n        }\n      });\n      if (error) {\n        throw new Error(`Failed to list files: ${error.message}`);\n      }\n\n      // Get public URLs for each file\n      const filesWithUrls = data.map(file => {\n        var _file$metadata;\n        const fullPath = `${folderPath}/${file.name}`;\n        const {\n          data: urlData\n        } = supabase.storage.from('User_Files').getPublicUrl(fullPath);\n        return {\n          name: file.name,\n          path: fullPath,\n          size: ((_file$metadata = file.metadata) === null || _file$metadata === void 0 ? void 0 : _file$metadata.size) || 0,\n          lastModified: file.updated_at,\n          publicUrl: urlData.publicUrl,\n          type: this.getFileType(file.name)\n        };\n      });\n      return {\n        success: true,\n        files: filesWithUrls\n      };\n    } catch (error) {\n      console.error('Supabase list error:', error);\n      return {\n        success: false,\n        error: error.message,\n        files: []\n      };\n    }\n  },\n  /**\n   * Delete a file from the User_Files bucket\n   * @param {string} filePath - Full path to the file\n   * @returns {Promise<Object>} Delete result\n   */\n  async deleteFile(filePath) {\n    try {\n      const {\n        data,\n        error\n      } = await supabase.storage.from('User_Files').remove([filePath]);\n      if (error) {\n        throw new Error(`Failed to delete file: ${error.message}`);\n      }\n      return {\n        success: true,\n        message: 'File deleted successfully'\n      };\n    } catch (error) {\n      console.error('Supabase delete error:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  },\n  /**\n   * Get file type based on extension\n   * @param {string} filename - Name of the file\n   * @returns {string} File type\n   */\n  getFileType(filename) {\n    var _filename$split$pop;\n    const extension = (_filename$split$pop = filename.split('.').pop()) === null || _filename$split$pop === void 0 ? void 0 : _filename$split$pop.toLowerCase();\n    switch (extension) {\n      case 'pdf':\n        return 'PDF';\n      case 'doc':\n      case 'docx':\n        return 'DOC';\n      case 'xls':\n      case 'xlsx':\n        return 'XLS';\n      case 'ppt':\n      case 'pptx':\n        return 'PPT';\n      case 'txt':\n        return 'TXT';\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n      case 'gif':\n        return 'IMG';\n      default:\n        return 'FILE';\n    }\n  },\n  /**\n   * Format file size for display\n   * @param {number} bytes - File size in bytes\n   * @returns {string} Formatted file size\n   */\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n};\nexport default supabaseService;","map":{"version":3,"names":["createClient","supabaseUrl","process","env","REACT_APP_SUPABASE_URL","supabaseAnonKey","REACT_APP_SUPABASE_ANON_KEY","supabase","supabaseService","uploadFile","file","userId","category","timestamp","Date","getTime","fileExtension","name","split","pop","fileName","replace","console","log","data","error","storage","from","upload","cacheControl","upsert","Error","message","urlData","getPublicUrl","success","filePath","path","publicUrl","fileSize","size","fileType","type","uploadedAt","toISOString","listFiles","folderPath","list","limit","offset","sortBy","column","order","filesWithUrls","map","_file$metadata","fullPath","metadata","lastModified","updated_at","getFileType","files","deleteFile","remove","filename","_filename$split$pop","extension","toLowerCase","formatFileSize","bytes","k","sizes","i","Math","floor","parseFloat","pow","toFixed"],"sources":["/Users/jasnoorsandhu51/Documents/Software-Engineering-Team-6/frontend/src/services/supabaseService.js"],"sourcesContent":["import { createClient } from '@supabase/supabase-js';\n\n// Initialize Supabase client\nconst supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'https://xmdfjheusbiqklrqxgow.supabase.co';\nconst supabaseAnonKey = process.env.REACT_APP_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhtZGZqaGV1c2JpcWtscnF4Z293Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkyNDkzMzUsImV4cCI6MjA3NDgyNTMzNX0.3GsHStv3AqLjWIAZjL8hY4ESEJ-T4MdIpVkebzJ2aaI';\n\nconst supabase = createClient(supabaseUrl, supabaseAnonKey);\n\nexport const supabaseService = {\n  /**\n   * Upload a file to the User_Files bucket\n   * @param {File} file - The file to upload\n   * @param {string} userId - User ID for organizing files\n   * @param {string} category - Category for organizing files (academic, schedule, documents, resources)\n   * @returns {Promise<Object>} Upload result with file path and URL\n   */\n  async uploadFile(file, userId = 'default_user', category = 'documents') {\n    try {\n      // Generate unique filename with timestamp\n      const timestamp = new Date().getTime();\n      const fileExtension = file.name.split('.').pop();\n      const fileName = `${userId}/${category}/${timestamp}_${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;\n\n      console.log('Uploading file:', fileName);\n\n      // Upload file to Supabase Storage\n      const { data, error } = await supabase.storage\n        .from('User_Files')\n        .upload(fileName, file, {\n          cacheControl: '3600',\n          upsert: false\n        });\n\n      if (error) {\n        console.error('Upload error:', error);\n        throw new Error(`Upload failed: ${error.message}`);\n      }\n\n      // Get public URL for the uploaded file\n      const { data: urlData } = supabase.storage\n        .from('User_Files')\n        .getPublicUrl(fileName);\n\n      console.log('File uploaded successfully:', data);\n\n      return {\n        success: true,\n        filePath: data.path,\n        publicUrl: urlData.publicUrl,\n        fileName: file.name,\n        fileSize: file.size,\n        fileType: file.type || 'application/octet-stream',\n        uploadedAt: new Date().toISOString(),\n        category\n      };\n\n    } catch (error) {\n      console.error('Supabase upload error:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  },\n\n  /**\n   * List files from the User_Files bucket\n   * @param {string} userId - User ID to filter files\n   * @param {string} category - Optional category filter\n   * @returns {Promise<Array>} List of files\n   */\n  async listFiles(userId = 'default_user', category = null) {\n    try {\n      const folderPath = category ? `${userId}/${category}` : userId;\n      \n      const { data, error } = await supabase.storage\n        .from('User_Files')\n        .list(folderPath, {\n          limit: 100,\n          offset: 0,\n          sortBy: { column: 'created_at', order: 'desc' }\n        });\n\n      if (error) {\n        throw new Error(`Failed to list files: ${error.message}`);\n      }\n\n      // Get public URLs for each file\n      const filesWithUrls = data.map(file => {\n        const fullPath = `${folderPath}/${file.name}`;\n        const { data: urlData } = supabase.storage\n          .from('User_Files')\n          .getPublicUrl(fullPath);\n\n        return {\n          name: file.name,\n          path: fullPath,\n          size: file.metadata?.size || 0,\n          lastModified: file.updated_at,\n          publicUrl: urlData.publicUrl,\n          type: this.getFileType(file.name)\n        };\n      });\n\n      return {\n        success: true,\n        files: filesWithUrls\n      };\n\n    } catch (error) {\n      console.error('Supabase list error:', error);\n      return {\n        success: false,\n        error: error.message,\n        files: []\n      };\n    }\n  },\n\n  /**\n   * Delete a file from the User_Files bucket\n   * @param {string} filePath - Full path to the file\n   * @returns {Promise<Object>} Delete result\n   */\n  async deleteFile(filePath) {\n    try {\n      const { data, error } = await supabase.storage\n        .from('User_Files')\n        .remove([filePath]);\n\n      if (error) {\n        throw new Error(`Failed to delete file: ${error.message}`);\n      }\n\n      return {\n        success: true,\n        message: 'File deleted successfully'\n      };\n\n    } catch (error) {\n      console.error('Supabase delete error:', error);\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n  },\n\n  /**\n   * Get file type based on extension\n   * @param {string} filename - Name of the file\n   * @returns {string} File type\n   */\n  getFileType(filename) {\n    const extension = filename.split('.').pop()?.toLowerCase();\n    switch (extension) {\n      case 'pdf': return 'PDF';\n      case 'doc':\n      case 'docx': return 'DOC';\n      case 'xls':\n      case 'xlsx': return 'XLS';\n      case 'ppt':\n      case 'pptx': return 'PPT';\n      case 'txt': return 'TXT';\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n      case 'gif': return 'IMG';\n      default: return 'FILE';\n    }\n  },\n\n  /**\n   * Format file size for display\n   * @param {number} bytes - File size in bytes\n   * @returns {string} Formatted file size\n   */\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n};\n\nexport default supabaseService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}